use tauri::command;
use crate::services::exploit_sandbox::{
    get_exploit_templates, simulate_exploit, ExploitPayload, AttackResult
};

#[derive(serde::Serialize)]
pub struct ExploitPayloadResponse {
    pub payloads: Vec<ExploitPayload>,
}

#[command]
pub fn get_exploit_payloads() -> ExploitPayloadResponse {
    ExploitPayloadResponse {
        payloads: get_exploit_templates()
    }
}

#[command]
pub fn run_exploit_simulation(code: String, payload_index: usize) -> Result<AttackResult, String> {
    let payloads = get_exploit_templates();
    
    if payload_index >= payloads.len() {
        return Err(format!("Invalid payload index: {}", payload_index));
    }
    
    let payload = &payloads[payload_index];
    Ok(simulate_exploit(&code, payload))
}

#[command]
pub fn run_exploit_with_custom_payload(
    code: String, 
    payload_name: String,
    payload_content: String,
    attack_type: String
) -> Result<AttackResult, String> {
    use crate::services::exploit_sandbox::AttackType;
    
    let attack_type_enum = match attack_type.to_lowercase().as_str() {
        "sql" | "sqli" | "sqlinjection" => AttackType::SqlInjection,
        "cmd" | "cmdi" | "commandinjection" => AttackType::CommandInjection,
        "xss" => AttackType::XSS,
        "path" | "pathtraversal" | "lfi" => AttackType::PathTraversal,
        "deserial" | "deserialization" => AttackType::Deserialization,
        _ => return Err(format!("Unknown attack type: {}", attack_type)),
    };
    
    let custom_payload = ExploitPayload {
        name: payload_name,
        attack_type: attack_type_enum,
        payload: payload_content,
        description: "Custom payload".to_string(),
        target_pattern: r".*".to_string(), // Match anything for custom payloads
    };
    
    Ok(simulate_exploit(&code, &custom_payload))
}
