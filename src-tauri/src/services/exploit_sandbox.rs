use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::process::{Command, Stdio};
use std::time::Duration;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AttackType {
    SqlInjection,
    CommandInjection,
    XSS,
    PathTraversal,
    Deserialization,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExploitPayload {
    pub name: String,
    pub attack_type: AttackType,
    pub payload: String,
    pub description: String,
    pub target_pattern: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AttackResult {
    pub success: bool,
    pub attack_type: String,
    pub payload_used: String,
    pub vulnerability_found: bool,
    pub impact_description: String,
    pub data_exposed: Option<String>,
    pub attack_chain: Vec<AttackStep>,
    pub risk_score: u8,
    pub cwe: Option<String>,
    pub mitigation: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AttackStep {
    pub step_number: u8,
    pub action: String,
    pub result: String,
    pub status: StepStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum StepStatus {
    Success,
    Failed,
    Blocked,
}

/// Get available exploit payloads
pub fn get_exploit_templates() -> Vec<ExploitPayload> {
    vec![
        // SQL Injection payloads
        ExploitPayload {
            name: "SQL Auth Bypass".to_string(),
            attack_type: AttackType::SqlInjection,
            payload: "' OR '1'='1' --".to_string(),
            description: "Bypass authentication by making WHERE clause always true".to_string(),
            target_pattern: r"SELECT.*WHERE.*=.*'".to_string(),
        },
        ExploitPayload {
            name: "SQL UNION Attack".to_string(),
            attack_type: AttackType::SqlInjection,
            payload: "' UNION SELECT username, password FROM users --".to_string(),
            description: "Extract data from other tables using UNION".to_string(),
            target_pattern: r"SELECT.*FROM".to_string(),
        },
        ExploitPayload {
            name: "SQL Time-Based Blind".to_string(),
            attack_type: AttackType::SqlInjection,
            payload: "' AND SLEEP(5) --".to_string(),
            description: "Detect SQL injection via response timing".to_string(),
            target_pattern: r"SELECT.*WHERE".to_string(),
        },
        
        // Command Injection payloads
        ExploitPayload {
            name: "Command Chain".to_string(),
            attack_type: AttackType::CommandInjection,
            payload: "; cat /etc/passwd".to_string(),
            description: "Chain commands using semicolon to read sensitive files".to_string(),
            target_pattern: r"os\.system|subprocess|exec".to_string(),
        },
        ExploitPayload {
            name: "Command Substitution".to_string(),
            attack_type: AttackType::CommandInjection,
            payload: "$(whoami)".to_string(),
            description: "Inject command using substitution syntax".to_string(),
            target_pattern: r"os\.system|subprocess".to_string(),
        },
        ExploitPayload {
            name: "Backtick Injection".to_string(),
            attack_type: AttackType::CommandInjection,
            payload: "`id`".to_string(),
            description: "Inject command using backticks".to_string(),
            target_pattern: r"exec|system".to_string(),
        },
        
        // XSS payloads
        ExploitPayload {
            name: "Script Tag XSS".to_string(),
            attack_type: AttackType::XSS,
            payload: "<script>alert('XSS')</script>".to_string(),
            description: "Classic script tag injection".to_string(),
            target_pattern: r"innerHTML|document\.write".to_string(),
        },
        ExploitPayload {
            name: "Event Handler XSS".to_string(),
            attack_type: AttackType::XSS,
            payload: "<img src=x onerror=alert('XSS')>".to_string(),
            description: "XSS via image error event".to_string(),
            target_pattern: r"innerHTML".to_string(),
        },
        ExploitPayload {
            name: "SVG XSS".to_string(),
            attack_type: AttackType::XSS,
            payload: "<svg onload=alert('XSS')>".to_string(),
            description: "XSS via SVG onload event".to_string(),
            target_pattern: r"innerHTML|insertAdjacentHTML".to_string(),
        },
        
        // Path Traversal payloads
        ExploitPayload {
            name: "Basic Path Traversal".to_string(),
            attack_type: AttackType::PathTraversal,
            payload: "../../../etc/passwd".to_string(),
            description: "Navigate up directories to access sensitive files".to_string(),
            target_pattern: r"open\(|read_file|include".to_string(),
        },
        ExploitPayload {
            name: "Encoded Path Traversal".to_string(),
            attack_type: AttackType::PathTraversal,
            payload: "..%2F..%2F..%2Fetc%2Fpasswd".to_string(),
            description: "URL-encoded path traversal".to_string(),
            target_pattern: r"open\(|file_get_contents".to_string(),
        },
        
        // Deserialization payloads
        ExploitPayload {
            name: "Python Pickle RCE".to_string(),
            attack_type: AttackType::Deserialization,
            payload: "__reduce__: os.system('id')".to_string(),
            description: "Remote code execution via pickle deserialization".to_string(),
            target_pattern: r"pickle\.load".to_string(),
        },
    ]
}

/// Simulate an exploit against code
pub fn simulate_exploit(code: &str, payload: &ExploitPayload) -> AttackResult {
    let mut attack_chain = Vec::new();
    let mut vulnerability_found = false;
    let mut impact_description = String::new();
    let mut data_exposed = None;
    let mut risk_score: u8 = 0;
    
    // Check if the code contains the vulnerable pattern
    let pattern_regex = regex::Regex::new(&payload.target_pattern).ok();
    let has_vulnerable_pattern = pattern_regex
        .as_ref()
        .map(|re| re.is_match(code))
        .unwrap_or(false);
    
    if has_vulnerable_pattern {
        vulnerability_found = true;
        
        // Step 1: Identify vulnerability
        attack_chain.push(AttackStep {
            step_number: 1,
            action: "Scan for vulnerable patterns".to_string(),
            result: format!("Found vulnerable pattern: {}", payload.target_pattern),
            status: StepStatus::Success,
        });
        
        // Step 2: Craft payload
        attack_chain.push(AttackStep {
            step_number: 2,
            action: "Craft exploit payload".to_string(),
            result: format!("Payload: {}", payload.payload),
            status: StepStatus::Success,
        });
        
        // Step 3: Simulate injection
        attack_chain.push(AttackStep {
            step_number: 3,
            action: "Inject payload".to_string(),
            result: "Payload injected into vulnerable sink".to_string(),
            status: StepStatus::Success,
        });
        
        // Determine impact based on attack type
        match payload.attack_type {
            AttackType::SqlInjection => {
                risk_score = 9;
                impact_description = "Database can be queried or modified. Authentication bypass possible.".to_string();
                data_exposed = Some("User credentials, personal data".to_string());
                attack_chain.push(AttackStep {
                    step_number: 4,
                    action: "Execute SQL payload".to_string(),
                    result: "SQL injection successful - data exfiltrated".to_string(),
                    status: StepStatus::Success,
                });
            },
            AttackType::CommandInjection => {
                risk_score = 10;
                impact_description = "Remote code execution achieved. Full system compromise possible.".to_string();
                data_exposed = Some("System files, environment variables".to_string());
                attack_chain.push(AttackStep {
                    step_number: 4,
                    action: "Execute system command".to_string(),
                    result: "Command executed with application privileges".to_string(),
                    status: StepStatus::Success,
                });
            },
            AttackType::XSS => {
                risk_score = 7;
                impact_description = "Client-side code execution. Session hijacking, credential theft possible.".to_string();
                data_exposed = Some("Session tokens, cookies, user input".to_string());
                attack_chain.push(AttackStep {
                    step_number: 4,
                    action: "Execute JavaScript in browser".to_string(),
                    result: "XSS payload rendered in victim's browser".to_string(),
                    status: StepStatus::Success,
                });
            },
            AttackType::PathTraversal => {
                risk_score = 8;
                impact_description = "Arbitrary file read. Sensitive configuration and secrets exposed.".to_string();
                data_exposed = Some("/etc/passwd, config files, .env files".to_string());
                attack_chain.push(AttackStep {
                    step_number: 4,
                    action: "Read file outside web root".to_string(),
                    result: "Sensitive file contents retrieved".to_string(),
                    status: StepStatus::Success,
                });
            },
            AttackType::Deserialization => {
                risk_score = 10;
                impact_description = "Remote code execution via deserialization. Complete system takeover possible.".to_string();
                data_exposed = Some("Full system access".to_string());
                attack_chain.push(AttackStep {
                    step_number: 4,
                    action: "Deserialize malicious object".to_string(),
                    result: "Arbitrary code executed during deserialization".to_string(),
                    status: StepStatus::Success,
                });
            },
        }
    } else {
        // No vulnerability found or attack blocked
        attack_chain.push(AttackStep {
            step_number: 1,
            action: "Scan for vulnerable patterns".to_string(),
            result: "No vulnerable patterns found".to_string(),
            status: StepStatus::Failed,
        });
        impact_description = "Attack unsuccessful. Code appears secure against this vector.".to_string();
        risk_score = 0;
    }
    
    let attack_type_str = match payload.attack_type {
        AttackType::SqlInjection => "SQL Injection",
        AttackType::CommandInjection => "Command Injection",
        AttackType::XSS => "Cross-Site Scripting (XSS)",
        AttackType::PathTraversal => "Path Traversal",
        AttackType::Deserialization => "Insecure Deserialization",
    };
    
    let cwe = match payload.attack_type {
        AttackType::SqlInjection => Some("CWE-89".to_string()),
        AttackType::CommandInjection => Some("CWE-78".to_string()),
        AttackType::XSS => Some("CWE-79".to_string()),
        AttackType::PathTraversal => Some("CWE-22".to_string()),
        AttackType::Deserialization => Some("CWE-502".to_string()),
    };
    
    let mitigation = match payload.attack_type {
        AttackType::SqlInjection => "Use parameterized queries or prepared statements",
        AttackType::CommandInjection => "Use subprocess with shell=False, sanitize inputs",
        AttackType::XSS => "Sanitize output, use Content-Security-Policy",
        AttackType::PathTraversal => "Validate paths, use allowlist, resolve canonically",
        AttackType::Deserialization => "Never deserialize untrusted data, use JSON instead",
    };
    
    AttackResult {
        success: vulnerability_found,
        attack_type: attack_type_str.to_string(),
        payload_used: payload.payload.clone(),
        vulnerability_found,
        impact_description,
        data_exposed,
        attack_chain,
        risk_score,
        cwe,
        mitigation: mitigation.to_string(),
    }
}
